#!/usr/bin/env groovy

/**
 * Executes a list of jobs either in parallel or sequentially.
 *
 * Supports two invocation styles:
 * 1. Old Way: stdRun(block: 'bootstrap', action: 'init', parallel: false)
 * 2. New Way: stdRun(jobNames: ['job1', 'job2'], parallel: true)
 *
 * @param params A map of parameters. Can include:
 *               - block: The block to filter (Old Way)
 *               - action: The action within the block (Old Way)
 *               - jobNames: A list of jobNames to execute (New Way)
 *               - parallel: Boolean indicating parallel execution (default: true)
 */
def call(Map params = [:]) {
    script {
        loadResourceScript "execute.sh"

        def parallelFlag = params.get('parallel', true)

        // Set global environment variables
        setGlobalEnvVars()

        // Read the outputs.json file generated by stdDiscover
        def hits = readHitsJson()

        // Retrieve tasks based on provided parameters
        def tasks = getTasks(hits, params)
        if (tasks.isEmpty()) {
            echo "No tasks to execute."
            return
        }

        executeTasks(tasks, parallelFlag)
    }
}

/**
 * Sets the global environment variables.
 */
def setGlobalEnvVars() {
    env.PRJ_ROOT = pwd()
    env.PRJ_DATA_HOME = "${env.TMP_DIR}/.data"
    env.PRJ_CACHE_HOME = "${env.TMP_DIR}/.cache"
    env.PRJ_CONFIG_HOME = "${env.TMP_DIR}/.config"
    env.PRJ_RUNTIME_DIR = "${env.TMP_DIR}/.run"
    env.PRJ_PATH = "${env.TMP_DIR}/.bin"
    env.TERM = "xterm-256color"

    env.DRV_IMPORT_FROM_DISCOVERY = false
    env.REMOTE_STORE = false
    env.EVALSTORE_IMPORT = "${env.TMP_DIR}/eval-store"
}

/**
 * Reads the hits JSON file and returns its content.
 *
 * @return The content of the hits JSON file.
 */
def readHitsJson() {
    def hitsFile = "${env.TMP_DIR}/outputs.json"
    if (!fileExists(hitsFile)) {
        error "File '${hitsFile}' does not exist. Ensure the 'Discover' stage has been executed."
    }
    return readJSON(file: hitsFile)
}

/**
 * Retrieves tasks based on provided parameters.
 *
 * @param hits   The content of the hits JSON file.
 * @param params The parameters map.
 * @return A list of tasks to execute.
 */
def getTasks(hits, Map params) {
    if (params.containsKey('jobNames')) {
        return getTasksByJobNames(hits, params.jobNames)
    } else if (params.containsKey('block') && params.containsKey('action')) {
        return getTasksByBlockAndAction(hits, params.block, params.action)
    } else {
        error "Invalid parameters for stdRun. Provide either 'jobNames' or both 'block' and 'action'."
    }
}

/**
 * Retrieves tasks based on job names.
 *
 * @param hits     The content of the hits JSON file.
 * @param jobNames The list of job names.
 * @return A list of tasks to execute.
 */
def getTasksByJobNames(hits, jobNames) {
    if (!(jobNames instanceof List)) {
        error "Parameter 'jobNames' must be a list of strings."
    }
    if (jobNames.isEmpty()) {
        echo "The 'jobNames' list is empty. No tasks to execute."
        return []
    }

    def tasks = jobNames.collect { jobName ->
        def task = findTaskByJobName(hits, jobName)
        if (!task) {
            error "Job with jobName '${jobName}' not found in outputs.json."
        }
        return task
    }
    return tasks
}

/**
 * Finds a task by job name within the hits JSON content.
 *
 * @param hits    The content of the hits JSON file.
 * @param jobName The job name to search for.
 * @return The task object if found, null otherwise.
 */
def findTaskByJobName(hits, jobName) {
    hits.values().findResult { block ->
        block.values().findResult { actionTasks ->
            actionTasks.find { task -> task.jobName == jobName }
        }
    }
}

/**
 * Retrieves tasks based on block and action.
 *
 * @param hits   The content of the hits JSON file.
 * @param block  The block name.
 * @param action The action name.
 * @return A list of tasks to execute.
 */
def getTasksByBlockAndAction(hits, block, action) {
    if (!hits.containsKey(block)) {
        error "Block '${block}' does not exist in the hits JSON."
    }
    if (!hits[block].containsKey(action)) {
        error "Action '${action}' does not exist within block '${block}' in the hits JSON."
    }
    return hits[block][action]
}

/**
 * Helper function to execute tasks.
 *
 * @param tasks    List of task objects to execute.
 * @param parallel Boolean indicating if tasks should run in parallel.
 */
def executeTasks(List tasks, Boolean parallel) {
    // Ensure all tasks have unique jobNames
    def jobNames = tasks.collect { it.jobName }
    def duplicateJobNames = jobNames.findAll { jobName -> jobNames.count(jobName) > 1 }.unique()
    if (duplicateJobNames) {
        error "Duplicate job names found: ${duplicateJobNames.join(', ')}. Ensure each job has a unique name."
    }

    // Build taskMap using collectEntries without referencing taskMap inside the closure
    Map taskMap = tasks.collectEntries { task ->
        def jobName = task.jobName
        if (!jobName) {
            error "Each task must have a 'jobName'."
        }
        [(jobName): createTaskClosure(task)]
    }

    if (parallel && taskMap.size() > 1) {
        // Execute all tasks in parallel
        parallel(taskMap)
    } else {
        // Execute tasks sequentially
        taskMap.values().each { it.call() }
    }
}

/**
 * Creates a task closure for execution.
 *
 * @param task The task object.
 * @return A closure that executes the task.
 */
def createTaskClosure(task) {
    def envVars = buildEnvVars(task)
    def jobName = task.jobName
    return {
        withEnv(envVars) {
            stage(jobName) {
                echo "Starting job: ${jobName}"
                sh "bash ./execute.sh"
                echo "Completed job: ${jobName}"
            }
        }
    }
}

/**
 * Builds environment variables for a task.
 *
 * @param task The task object.
 * @return A list of environment variables.
 */
def buildEnvVars(task) {
    def baseEnvVars = [
        "action=${task.action}",
        "target=${task.name}",
        "cell=${task.cell}",
        "block=${task.block}",
        "actionDrv=${task.actionDrv}"
    ]
    def additionalEnvVars = task.get("envConfig", [])
    return baseEnvVars + additionalEnvVars
}
